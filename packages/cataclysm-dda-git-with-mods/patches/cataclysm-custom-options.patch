diff --git a/data/core/external_options.json b/data/core/external_options.json
index 52b4263204f4..e6c94f558d96 100644
--- a/data/core/external_options.json
+++ b/data/core/external_options.json
@@ -520,5 +520,96 @@
     "//": "The maximum number of overmaps that an intersection can deviate from its gridded position. Cannot be greater than or equal to row / 2 or column / 2, may cause bugs for > row / 4, column / 4.",
     "stype": "int",
     "value": 2
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "UNSTABLE_TRAIT_MUTATION_TIME",
+    "//": "The average hours between mutations with the unstable trait.",
+    "stype": "int",
+    "value": 48
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "CHAOTIC_TRAIT_MUTATION_TIME",
+    "//": "The average hours between mutations with the chaotic trait.",
+    "stype": "int",
+    "value": 12
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "BASE_MANA_REGEN_TIME",
+    "//": "How many hours it should take to regenerate all mana at base mana regen.",
+    "stype": "float",
+    "value": 8.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "BASE_MANA_REGEN_TIME",
+    "//": "How many hours it should take to regenerate all mana at base mana regen.",
+    "stype": "float",
+    "value": 8.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "CROP_GROWTH_TIME_SCALER",
+    "//": "A scaler for how long crops take to grow. 0.5 will make crops take half as much time to grow.",
+    "stype": "float",
+    "value": 1.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "CROP_YIELD_MULTIPLIER",
+    "//": "How to scale crop yields. 2.0 will double crop yields.",
+    "stype": "float",
+    "value": 1.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "SHELF_LIFE_MULTIPLIER",
+    "//": "How much longer than normal foods will last. 2.0 will cause foods to last twice as long.",
+    "stype": "float",
+    "value": 1.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "TRADER_AVOID_ITEMS",
+    "//": "Whether traders will respect the TRADER_AVOID flag and refuse to buy items marked with it.",
+    "stype": "bool",
+    "value": true
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "TRADER_AVOID_FILTHY",
+    "//": "Whether traders will refuse to buy filthy items or not.",
+    "stype": "bool",
+    "value": true
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "DONT_AUTOLEARN_BOOK_RECIPES",
+    "//": "Whether to prevent autolearning recipes which can be learned via a book.",
+    "stype": "bool",
+    "value": false
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "DONT_AUTOLEARN_DISASSEMBLY_RECIPES",
+    "//": "Whether to prevent autolearning recipes which can be learned via disassembly.",
+    "stype": "bool",
+    "value": false
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "REQUIRE_THEORETICAL_KNOWLEDGE_TO_LEARN",
+    "//": "Learning practical skill will no longer increase your theoretical skill, so you need to learn from books to get any skill.",
+    "stype": "bool",
+    "value": false
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "EREADER_DRAIN_INTERVAL_MULTIPLIER",
+    "//": "A multiplier for how often reading ebooks should drain power, where 2.0 means it will take twice as long between power usages, and use half the power.",
+    "stype": "float",
+    "value": 1.0
   }
 ]
diff --git a/src/activity_actor.cpp b/src/activity_actor.cpp
index b9c4d9d769e1..52732cf3606b 100644
--- a/src/activity_actor.cpp
+++ b/src/activity_actor.cpp
@@ -2068,7 +2068,7 @@ void read_activity_actor::do_turn( player_activity &act, Character &who )
         return;
     }
 
-    if( using_ereader && calendar::once_every( 5_minutes ) ) {
+    if( using_ereader && calendar::once_every( 5_minutes * ::get_option<float>( "EREADER_DRAIN_INTERVAL_MULTIPLIER" ) ) ) {
         /** Expected battery life while reading with common ereaders:
                 integrated_ar       - implant                                         = potentially infinite
                 ar_glasses_advanced - max 300 charges from disposable light battery   = 25 hours of reading
diff --git a/src/activity_item_handling.cpp b/src/activity_item_handling.cpp
index 4e947e04c895..ae5300772726 100644
--- a/src/activity_item_handling.cpp
+++ b/src/activity_item_handling.cpp
@@ -4396,8 +4396,9 @@ static int get_comestible_order( Character &you, const item_location &loc,
 static time_duration get_comestible_time_left( const item_location &loc )
 {
     time_duration time_left = 0_turns;
-    const time_duration shelf_life = loc->is_comestible() ? loc->get_comestible()->spoils :
-                                     calendar::INDEFINITELY_LONG_DURATION;
+    const time_duration shelf_life =
+        loc->is_comestible() ? loc->get_comestible()->spoils  * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" ):
+                calendar::INDEFINITELY_LONG_DURATION;
     if( shelf_life > 0_turns ) {
         const item &it = *loc;
         const double relative_rot = it.get_relative_rot();
diff --git a/src/character.cpp b/src/character.cpp
index d81c44ed40b0..8051a1628d7c 100644
--- a/src/character.cpp
+++ b/src/character.cpp
@@ -2446,6 +2446,16 @@ bool Character::practice( const skill_id &id, int amount, int cap, bool suppress
         return false;
     }
 
+    if( ::get_option<bool>( "REQUIRE_THEORETICAL_KNOWLEDGE_TO_LEARN" ) ) {
+        int theoretical_level = level.knowledgeLevel() * 100 + std::max( 0, level.knowledgeExperience() );
+        int practical_level = level.level() * 100 + std::max( 0, level.exercise() );
+        if( practical_level >= theoretical_level ) {
+            // Don't practice if we need more theoretical knowledge.
+            return false;
+        }
+    }
+
+
     // Your ability to "catch up" skill experience to knowledge is mostly a function of intelligence,
     // but perception also plays a role, representing both memory/attentiveness and catching on to how
     // the two apply to each other.
diff --git a/src/game_inventory.cpp b/src/game_inventory.cpp
index fd21d509dcea..dfda2ab5f871 100644
--- a/src/game_inventory.cpp
+++ b/src/game_inventory.cpp
@@ -721,8 +721,9 @@ class comestible_inventory_preset : public inventory_selector_preset
             }, _( "HEALTH" ) );
 
             append_cell( []( const item_location & loc ) {
-                const time_duration spoils = loc->is_comestible() ? loc->get_comestible()->spoils :
-                                             calendar::INDEFINITELY_LONG_DURATION;
+                const time_duration spoils =
+                        loc->is_comestible() ? loc->get_comestible()->spoils * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" ) :
+                                calendar::INDEFINITELY_LONG_DURATION;
                 if( spoils > 0_turns ) {
                     return to_string_clipped( spoils );
                 }
diff --git a/src/iexamine.cpp b/src/iexamine.cpp
index 71b2554379ff..56703ae457a7 100644
--- a/src/iexamine.cpp
+++ b/src/iexamine.cpp
@@ -2811,10 +2811,15 @@ void iexamine::harvest_plant( Character &you, const tripoint_bub_ms &examp, bool
 
             int skillLevel = round( you.get_skill_level( skill_survival ) );
             ///\EFFECT_SURVIVAL increases number of plants harvested from a seed
-            int plant_count = rng( skillLevel / 2, skillLevel );
+            float yield_multiplier = ::get_option<float>( "CROP_YIELD_MULTIPLIER" );
+            int plant_count = rng(
+                    static_cast<int>( skillLevel * yield_multiplier / 2.0 ),
+                    static_cast<int>( skillLevel * yield_multiplier ) );
             const auto &fp = here.furn( examp )->plant;
             plant_count *= fp->harvest_multiplier;
-            plant_count = std::min( std::max( plant_count, 1 ), 12 );
+            plant_count = std::min(
+                    std::max( plant_count, 1 ),
+                    static_cast<int>( 12.0 * yield_multiplier ) );
             int seedCount = std::max( 1, rng( plant_count / 4, plant_count / 2 ) );
             for( item &i : get_harvest_items( type, plant_count, seedCount, true ) ) {
                 if( from_activity ) {
diff --git a/src/item_degrade.cpp b/src/item_degrade.cpp
index d268dd459534..8473c641c486 100644
--- a/src/item_degrade.cpp
+++ b/src/item_degrade.cpp
@@ -437,9 +437,9 @@ time_duration item::get_shelf_life() const
 {
     if( goes_bad() ) {
         if( is_comestible() ) {
-            return get_comestible()->spoils;
+            return get_comestible()->spoils * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" );
         } else if( is_corpse() ) {
-            return 24_hours;
+            return 24_hours * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" );
         }
     }
     return 0_turns;
diff --git a/src/magic.cpp b/src/magic.cpp
index 3bf239c65b55..e69e5052f6a1 100644
--- a/src/magic.cpp
+++ b/src/magic.cpp
@@ -2517,7 +2517,8 @@ int known_magic::max_mana( const Character &guy ) const
 void known_magic::update_mana( const Character &guy, float turns )
 {
     // mana should replenish in 8 hours.
-    const double full_replenish = to_turns<double>( 8_hours );
+    const double full_replenish =
+        to_turns<double>( 1_hours ) * ::get_option<float>( "BASE_MANA_REGEN_TIME" );
     const double ratio = turns / full_replenish;
     mod_mana( guy, std::floor( ratio * std::max( 0.0,
                                guy.calculate_by_enchantment( static_cast<double>( max_mana(
diff --git a/src/map.cpp b/src/map.cpp
index 31ba5464a1e2..3b3848dd73d3 100644
--- a/src/map.cpp
+++ b/src/map.cpp
@@ -8845,7 +8845,7 @@ void map::grow_plant( const tripoint_bub_ms &p )
             target_stage = pair.first;
         } // Don't break the loop for the case where time has been rewound.
         // Advance to the time of the next stage for the next iteration.
-        time_to_grow_to_this_stage += pair.second;
+        time_to_grow_to_this_stage += pair.second * ::get_option<float>( "CROP_GROWTH_TIME_SCALER" );
     }
 
     const auto check_flag = []( const std::string & to_check ) {
diff --git a/src/npc.cpp b/src/npc.cpp
index 30d4a07148b9..0c006abfd194 100644
--- a/src/npc.cpp
+++ b/src/npc.cpp
@@ -2084,11 +2084,12 @@ ret_val<void> npc::wants_to_buy( const item &it, int at_price ) const
     }
 
 
-    if( it.has_flag( flag_TRADER_AVOID ) || it.has_var( VAR_TRADE_IGNORE ) ) {
+    if( ::get_option<bool>( "TRADER_AVOID_ITEMS" ) &&
+            ( it.has_flag( flag_TRADER_AVOID ) || it.has_var( VAR_TRADE_IGNORE ) ) ) {
         return ret_val<void>::make_failure( _( "Will never buy this" ) );
     }
 
-    if( it.is_filthy() ) {
+    if( ::get_option<bool>( "TRADER_AVOID_FILTHY" ) && it.is_filthy() ) {
         return ret_val<void>::make_failure( _( "Will not buy filthy items" ) );
     }
 
@@ -4021,5 +4022,3 @@ std::unique_ptr<talker> get_talker_for( npc *guy )
 {
     return std::make_unique<talker_npc>( guy );
 }
-
-
diff --git a/src/recipe.cpp b/src/recipe.cpp
index b0dd9f04c349..1a6c8bfdb40c 100644
--- a/src/recipe.cpp
+++ b/src/recipe.cpp
@@ -38,6 +38,7 @@
 #include "mapgendata.h"
 #include "math_defines.h"
 #include "npc.h"
+#include "options.h"
 #include "output.h"
 #include "proficiency.h"
 #include "recipe_dictionary.h"
@@ -689,6 +690,13 @@ void recipe::finalize()
         }
     }
 
+    if( ( ::get_option<bool>( "DONT_AUTOLEARN_BOOK_RECIPES" ) && !booksets.empty() ) ||
+            ( ::get_option<bool>( "DONT_AUTOLEARN_DISASSEMBLY_RECIPES" ) && !learn_by_disassembly.empty() ) ) {
+        // Prevent autolearning, since there's a way to learn it in the world.
+        autolearn = false;
+        autolearn_requirements.clear();
+    }
+
     // ensure result name is always in front of the name for searching in crafting menu
     if( !name_.empty() && !is_practice() && !is_nested() && result_ ) {
         name_ = translation::to_translation( string_format( name_.translated(),
diff --git a/src/skill.cpp b/src/skill.cpp
index ccc02127c027..febac736ab75 100644
--- a/src/skill.cpp
+++ b/src/skill.cpp
@@ -330,7 +330,11 @@ void SkillLevel::train( int amount, float catchup_modifier, float knowledge_modi
         return;
     }
     _rustAccumulator -= catchup_amount;
-    _knowledgeExperience += knowledge_amount;
+
+    if( !::get_option<bool>( "REQUIRE_THEORETICAL_KNOWLEDGE_TO_LEARN" ) ) {
+        // Avoid raising theoretical knowledge outside of book learning.
+        _knowledgeExperience += knowledge_amount;
+    }
 
     on_exercise_change( allow_multilevel );
     practice();
diff --git a/src/suffer.cpp b/src/suffer.cpp
index f0c234fac297..b35c7f978ebd 100644
--- a/src/suffer.cpp
+++ b/src/suffer.cpp
@@ -1112,9 +1112,9 @@ void suffer::from_other_mutations( Character &you )
     }
 
     bool should_mutate = you.has_trait( trait_UNSTABLE ) && !you.has_trait( trait_CHAOTIC_BAD ) &&
-                         one_turn_in( 48_hours );
+                         one_turn_in( 1_hours * ::get_option<int>( "UNSTABLE_TRAIT_MUTATION_TIME" ) );
     should_mutate |= ( you.has_trait( trait_CHAOTIC ) || you.has_trait( trait_CHAOTIC_BAD ) ) &&
-                     one_turn_in( 12_hours );
+                     one_turn_in( 1_hours * ::get_option<int>( "CHAOTIC_TRAIT_MUTATION_TIME" ) );
     if( should_mutate ) {
         you.mutate();
     }
