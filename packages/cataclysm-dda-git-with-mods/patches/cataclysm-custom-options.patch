diff --git a/data/core/external_options.json b/data/core/external_options.json
index 52b4263204f4..6ec0dfde1849 100644
--- a/data/core/external_options.json
+++ b/data/core/external_options.json
@@ -520,5 +520,89 @@
     "//": "The maximum number of overmaps that an intersection can deviate from its gridded position. Cannot be greater than or equal to row / 2 or column / 2, may cause bugs for > row / 4, column / 4.",
     "stype": "int",
     "value": 2
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "UNSTABLE_TRAIT_MUTATION_TIME",
+    "//": "The average hours between mutations with the unstable trait.",
+    "stype": "int",
+    "value": 48
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "CHAOTIC_TRAIT_MUTATION_TIME",
+    "//": "The average hours between mutations with the chaotic trait.",
+    "stype": "int",
+    "value": 12
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "BASE_MANA_REGEN_TIME",
+    "//": "How many hours it should take to regenerate all mana at base mana regen.",
+    "stype": "float",
+    "value": 8.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "BASE_MANA_REGEN_TIME",
+    "//": "How many hours it should take to regenerate all mana at base mana regen.",
+    "stype": "float",
+    "value": 8.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "CROP_GROWTH_TIME_SCALER",
+    "//": "A scaler for how long crops take to grow. 0.5 will make crops take half as much time to grow.",
+    "stype": "float",
+    "value": 1.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "SHELF_LIFE_MULTIPLIER",
+    "//": "How much longer than normal foods will last. 2.0 will cause foods to last twice as long.",
+    "stype": "float",
+    "value": 1.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "TRADER_AVOID_ITEMS",
+    "//": "Whether traders will respect the TRADER_AVOID flag and refuse to buy items marked with it.",
+    "stype": "bool",
+    "value": true
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "TRADER_AVOID_FILTHY",
+    "//": "Whether traders will refuse to buy filthy items or not.",
+    "stype": "bool",
+    "value": true
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "DONT_AUTOLEARN_BOOK_RECIPES",
+    "//": "Whether to prevent autolearning recipes which can be learned via a book.",
+    "stype": "bool",
+    "value": false
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "DONT_AUTOLEARN_DISASSEMBLY_RECIPES",
+    "//": "Whether to prevent autolearning recipes which can be learned via disassembly.",
+    "stype": "bool",
+    "value": false
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "REQUIRE_THEORETICAL_KNOWLEDGE_TO_LEARN",
+    "//": "Learning practical skill will no longer increase your theoretical skill, so you need to learn from books to get any skill.",
+    "stype": "bool",
+    "value": false
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "EREADER_DRAIN_INTERVAL_MULTIPLIER",
+    "//": "A multiplier for how often reading ebooks should drain power, where 2.0 means it will take twice as long between power usages, and use half the power.",
+    "stype": "float",
+    "value": 1.0
   }
 ]
diff --git a/src/activity_actor.cpp b/src/activity_actor.cpp
index fffece316641..056934850d31 100644
--- a/src/activity_actor.cpp
+++ b/src/activity_actor.cpp
@@ -2025,7 +2025,7 @@ void read_activity_actor::do_turn( player_activity &act, Character &who )
         return;
     }
 
-    if( using_ereader && calendar::once_every( 5_minutes ) ) {
+    if( using_ereader && calendar::once_every( 5_minutes * ::get_option<float>( "EREADER_DRAIN_INTERVAL_MULTIPLIER" ) ) ) {
         /** Expected battery life while reading with common ereaders:
                 integrated_ar       - implant                                         = potentially infinite
                 ar_glasses_advanced - max 300 charges from disposable light battery   = 25 hours of reading
diff --git a/src/activity_item_handling.cpp b/src/activity_item_handling.cpp
index 6f72daac2f7b..1dbad53cfe8c 100644
--- a/src/activity_item_handling.cpp
+++ b/src/activity_item_handling.cpp
@@ -4389,8 +4389,9 @@ static int get_comestible_order( Character &you, const item_location &loc,
 static time_duration get_comestible_time_left( const item_location &loc )
 {
     time_duration time_left = 0_turns;
-    const time_duration shelf_life = loc->is_comestible() ? loc->get_comestible()->spoils :
-                                     calendar::INDEFINITELY_LONG_DURATION;
+    const time_duration shelf_life =
+        loc->is_comestible() ? loc->get_comestible()->spoils  * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" ):
+                calendar::INDEFINITELY_LONG_DURATION;
     if( shelf_life > 0_turns ) {
         const item &it = *loc;
         const double relative_rot = it.get_relative_rot();
diff --git a/src/character.cpp b/src/character.cpp
index 6ef44ca17f8b..b2b2381487e1 100644
--- a/src/character.cpp
+++ b/src/character.cpp
@@ -2444,6 +2444,16 @@ bool Character::practice( const skill_id &id, int amount, int cap, bool suppress
         return false;
     }
 
+    if( ::get_option<bool>( "REQUIRE_THEORETICAL_KNOWLEDGE_TO_LEARN" ) ) {
+        int theoretical_level = level.knowledgeLevel() * 100 + std::max( 0, level.knowledgeExperience() );
+        int practical_level = level.level() * 100 + std::max( 0, level.exercise() );
+        if( practical_level >= theoretical_level ) {
+            // Don't practice if we need more theoretical knowledge.
+            return false;
+        }
+    }
+
+
     // Your ability to "catch up" skill experience to knowledge is mostly a function of intelligence,
     // but perception also plays a role, representing both memory/attentiveness and catching on to how
     // the two apply to each other.
diff --git a/src/game_inventory.cpp b/src/game_inventory.cpp
index b9e1db47997d..f1e12a3e71c4 100644
--- a/src/game_inventory.cpp
+++ b/src/game_inventory.cpp
@@ -717,8 +717,9 @@ class comestible_inventory_preset : public inventory_selector_preset
             }, _( "HEALTH" ) );
 
             append_cell( []( const item_location & loc ) {
-                const time_duration spoils = loc->is_comestible() ? loc->get_comestible()->spoils :
-                                             calendar::INDEFINITELY_LONG_DURATION;
+                const time_duration spoils =
+                        loc->is_comestible() ? loc->get_comestible()->spoils * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" ) :
+                                calendar::INDEFINITELY_LONG_DURATION;
                 if( spoils > 0_turns ) {
                     return to_string_clipped( spoils );
                 }
diff --git a/src/item_degrade.cpp b/src/item_degrade.cpp
index d268dd459534..8473c641c486 100644
--- a/src/item_degrade.cpp
+++ b/src/item_degrade.cpp
@@ -437,9 +437,9 @@ time_duration item::get_shelf_life() const
 {
     if( goes_bad() ) {
         if( is_comestible() ) {
-            return get_comestible()->spoils;
+            return get_comestible()->spoils * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" );
         } else if( is_corpse() ) {
-            return 24_hours;
+            return 24_hours * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" );
         }
     }
     return 0_turns;
diff --git a/src/magic.cpp b/src/magic.cpp
index 27f9f39a42cf..2ece788f73c9 100644
--- a/src/magic.cpp
+++ b/src/magic.cpp
@@ -2477,7 +2477,8 @@ int known_magic::max_mana( const Character &guy ) const
 void known_magic::update_mana( const Character &guy, float turns )
 {
     // mana should replenish in 8 hours.
-    const double full_replenish = to_turns<double>( 8_hours );
+    const double full_replenish =
+        to_turns<double>( 1_hours ) * ::get_option<float>( "BASE_MANA_REGEN_TIME" );
     const double ratio = turns / full_replenish;
     mod_mana( guy, std::floor( ratio * std::max( 0.0,
                                guy.calculate_by_enchantment( static_cast<double>( max_mana(
diff --git a/src/map.cpp b/src/map.cpp
index ea21f3801f08..dc741581f778 100644
--- a/src/map.cpp
+++ b/src/map.cpp
@@ -8717,7 +8717,7 @@ void map::grow_plant( const tripoint_bub_ms &p )
             target_stage = pair.first;
         } // Don't break the loop for the case where time has been rewound.
         // Advance to the time of the next stage for the next iteration.
-        time_to_grow_to_this_stage += pair.second;
+        time_to_grow_to_this_stage += pair.second * ::get_option<float>( "CROP_GROWTH_TIME_SCALER" );
     }
 
     const auto check_flag = []( const std::string & to_check ) {
diff --git a/src/npc.cpp b/src/npc.cpp
index 382fcb6a1f70..0d31b92335f1 100644
--- a/src/npc.cpp
+++ b/src/npc.cpp
@@ -2061,11 +2061,12 @@ ret_val<void> npc::wants_to_buy( const item &it, int at_price ) const
     }
 
 
-    if( it.has_flag( flag_TRADER_AVOID ) || it.has_var( VAR_TRADE_IGNORE ) ) {
+    if( ::get_option<bool>( "TRADER_AVOID_ITEMS" ) &&
+            ( it.has_flag( flag_TRADER_AVOID ) || it.has_var( VAR_TRADE_IGNORE ) ) ) {
         return ret_val<void>::make_failure( _( "Will never buy this" ) );
     }
 
-    if( it.is_filthy() ) {
+    if( ::get_option<bool>( "TRADER_AVOID_FILTHY" ) && it.is_filthy() ) {
         return ret_val<void>::make_failure( _( "Will not buy filthy items" ) );
     }
 
@@ -3998,5 +3999,3 @@ std::unique_ptr<talker> get_talker_for( npc *guy )
 {
     return std::make_unique<talker_npc>( guy );
 }
-
-
diff --git a/src/recipe.cpp b/src/recipe.cpp
index 8dfada73352d..a32e1ab0401b 100644
--- a/src/recipe.cpp
+++ b/src/recipe.cpp
@@ -38,6 +38,7 @@
 #include "mapgendata.h"
 #include "math_defines.h"
 #include "npc.h"
+#include "options.h"
 #include "output.h"
 #include "proficiency.h"
 #include "recipe_dictionary.h"
@@ -689,6 +690,13 @@ void recipe::finalize()
         }
     }
 
+    if( ( ::get_option<bool>( "DONT_AUTOLEARN_BOOK_RECIPES" ) && !booksets.empty() ) ||
+            ( ::get_option<bool>( "DONT_AUTOLEARN_DISASSEMBLY_RECIPES" ) && !learn_by_disassembly.empty() ) ) {
+        // Prevent autolearning, since there's a way to learn it in the world.
+        autolearn = false;
+        autolearn_requirements.clear();
+    }
+
     // ensure result name is always in front of the name for searching in crafting menu
     if( !name_.empty() && !is_practice() && !is_nested() && result_ ) {
         name_ = translation::to_translation( string_format( name_, result_->nname( makes_amount() ) ) );
diff --git a/src/skill.cpp b/src/skill.cpp
index ccc02127c027..febac736ab75 100644
--- a/src/skill.cpp
+++ b/src/skill.cpp
@@ -330,7 +330,11 @@ void SkillLevel::train( int amount, float catchup_modifier, float knowledge_modi
         return;
     }
     _rustAccumulator -= catchup_amount;
-    _knowledgeExperience += knowledge_amount;
+
+    if( !::get_option<bool>( "REQUIRE_THEORETICAL_KNOWLEDGE_TO_LEARN" ) ) {
+        // Avoid raising theoretical knowledge outside of book learning.
+        _knowledgeExperience += knowledge_amount;
+    }
 
     on_exercise_change( allow_multilevel );
     practice();
diff --git a/src/suffer.cpp b/src/suffer.cpp
index f0c234fac297..b35c7f978ebd 100644
--- a/src/suffer.cpp
+++ b/src/suffer.cpp
@@ -1112,9 +1112,9 @@ void suffer::from_other_mutations( Character &you )
     }
 
     bool should_mutate = you.has_trait( trait_UNSTABLE ) && !you.has_trait( trait_CHAOTIC_BAD ) &&
-                         one_turn_in( 48_hours );
+                         one_turn_in( 1_hours * ::get_option<int>( "UNSTABLE_TRAIT_MUTATION_TIME" ) );
     should_mutate |= ( you.has_trait( trait_CHAOTIC ) || you.has_trait( trait_CHAOTIC_BAD ) ) &&
-                     one_turn_in( 12_hours );
+                     one_turn_in( 1_hours * ::get_option<int>( "CHAOTIC_TRAIT_MUTATION_TIME" ) );
     if( should_mutate ) {
         you.mutate();
     }
