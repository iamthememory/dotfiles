diff --git a/src/weather.cpp b/src/weather.cpp
index 21d9faf7f687..352f6cc0408f 100644
--- a/src/weather.cpp
+++ b/src/weather.cpp
@@ -956,25 +956,31 @@ ret_val<void> warm_enough_to_plant( const tripoint_bub_ms &pos, const itype_id &
 {
     std::map<time_point, units::temperature> planting_times;
 
+#if 0
     if( !has_sunlight_access( pos ) ) {
         return ret_val<void>::make_failure( _( "Plants need sunlight to grow!  You can't plant there." ) );
     }
+#endif
 
     const tripoint_abs_ms abs = get_map().get_abs( pos );
     const tripoint_abs_omt checked_omt = project_to<coords::omt>( abs );
 
+#if 0
     const std::vector<std::pair<flag_id, time_duration>> &growth_stages = it->seed->get_growth_stages();
+#endif
     // we will iterate a copy of the weather into the future to see if they'll be plantable then as well.
     const weather_generator weather_gen = get_weather().get_cur_weather_gen();
     // initialize the first...
     time_point check_date = calendar::turn;
     planting_times[check_date] = highest_temp_on_day( check_date, checked_omt, weather_gen );
+#if 0
     for( const auto &pair : growth_stages ) {
         // TODO: Replace epoch checks with data from a farmer's almanac
         check_date = check_date + pair.second;
         // The [] operator in std::map inserts an entry if it doesn't already exist.
         planting_times[check_date] = highest_temp_on_day( check_date, checked_omt, weather_gen );
     }
+#endif
     for( const std::pair<const time_point, units::temperature> &pair : planting_times ) {
         // This absolutely needs to be a time point.
         add_msg_debug( debugmode::DF_MAP,
