diff --git a/data/core/external_options.json b/data/core/external_options.json
index 52b4263204f4..9bc946d78dd0 100644
--- a/data/core/external_options.json
+++ b/data/core/external_options.json
@@ -520,5 +520,61 @@
     "//": "The maximum number of overmaps that an intersection can deviate from its gridded position. Cannot be greater than or equal to row / 2 or column / 2, may cause bugs for > row / 4, column / 4.",
     "stype": "int",
     "value": 2
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "UNSTABLE_TRAIT_MUTATION_TIME",
+    "//": "The average hours between mutations with the unstable trait.",
+    "stype": "int",
+    "value": 48
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "CHAOTIC_TRAIT_MUTATION_TIME",
+    "//": "The average hours between mutations with the chaotic trait.",
+    "stype": "int",
+    "value": 12
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "BASE_MANA_REGEN_TIME",
+    "//": "How many hours it should take to regenerate all mana at base mana regen.",
+    "stype": "float",
+    "value": 8.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "BASE_MANA_REGEN_TIME",
+    "//": "How many hours it should take to regenerate all mana at base mana regen.",
+    "stype": "float",
+    "value": 8.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "CROP_GROWTH_TIME_SCALER",
+    "//": "A scaler for how long crops take to grow. 0.5 will make crops take half as much time to grow.",
+    "stype": "float",
+    "value": 1.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "SHELF_LIFE_MULTIPLIER",
+    "//": "How much longer than normal foods will last. 2.0 will cause foods to last twice as long.",
+    "stype": "float",
+    "value": 1.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "TRADER_AVOID_ITEMS",
+    "//": "Whether traders will respect the TRADER_AVOID flag and refuse to buy items marked with it.",
+    "stype": "bool",
+    "value": true
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "TRADER_AVOID_FILTHY",
+    "//": "Whether traders will refuse to buy filthy items or not.",
+    "stype": "bool",
+    "value": true
   }
 ]
diff --git a/src/activity_item_handling.cpp b/src/activity_item_handling.cpp
index 6f72daac2f7b..1dbad53cfe8c 100644
--- a/src/activity_item_handling.cpp
+++ b/src/activity_item_handling.cpp
@@ -4389,8 +4389,9 @@ static int get_comestible_order( Character &you, const item_location &loc,
 static time_duration get_comestible_time_left( const item_location &loc )
 {
     time_duration time_left = 0_turns;
-    const time_duration shelf_life = loc->is_comestible() ? loc->get_comestible()->spoils :
-                                     calendar::INDEFINITELY_LONG_DURATION;
+    const time_duration shelf_life =
+        loc->is_comestible() ? loc->get_comestible()->spoils  * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" ):
+                calendar::INDEFINITELY_LONG_DURATION;
     if( shelf_life > 0_turns ) {
         const item &it = *loc;
         const double relative_rot = it.get_relative_rot();
diff --git a/src/game_inventory.cpp b/src/game_inventory.cpp
index 37313fe176b8..651851bf93cc 100644
--- a/src/game_inventory.cpp
+++ b/src/game_inventory.cpp
@@ -710,8 +710,9 @@ class comestible_inventory_preset : public inventory_selector_preset
             }, _( "HEALTH" ) );
 
             append_cell( []( const item_location & loc ) {
-                const time_duration spoils = loc->is_comestible() ? loc->get_comestible()->spoils :
-                                             calendar::INDEFINITELY_LONG_DURATION;
+                const time_duration spoils =
+                        loc->is_comestible() ? loc->get_comestible()->spoils * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" ) :
+                                calendar::INDEFINITELY_LONG_DURATION;
                 if( spoils > 0_turns ) {
                     return to_string_clipped( spoils );
                 }
diff --git a/src/item_degrade.cpp b/src/item_degrade.cpp
index bb187070940f..919f369adb88 100644
--- a/src/item_degrade.cpp
+++ b/src/item_degrade.cpp
@@ -429,9 +429,9 @@ time_duration item::get_shelf_life() const
 {
     if( goes_bad() ) {
         if( is_comestible() ) {
-            return get_comestible()->spoils;
+            return get_comestible()->spoils * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" );
         } else if( is_corpse() ) {
-            return 24_hours;
+            return 24_hours * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" );
         }
     }
     return 0_turns;
diff --git a/src/magic.cpp b/src/magic.cpp
index 27f9f39a42cf..2ece788f73c9 100644
--- a/src/magic.cpp
+++ b/src/magic.cpp
@@ -2477,7 +2477,8 @@ int known_magic::max_mana( const Character &guy ) const
 void known_magic::update_mana( const Character &guy, float turns )
 {
     // mana should replenish in 8 hours.
-    const double full_replenish = to_turns<double>( 8_hours );
+    const double full_replenish =
+        to_turns<double>( 1_hours ) * ::get_option<float>( "BASE_MANA_REGEN_TIME" );
     const double ratio = turns / full_replenish;
     mod_mana( guy, std::floor( ratio * std::max( 0.0,
                                guy.calculate_by_enchantment( static_cast<double>( max_mana(
diff --git a/src/map.cpp b/src/map.cpp
index 63660372f817..03b6971e2bc0 100644
--- a/src/map.cpp
+++ b/src/map.cpp
@@ -8611,7 +8611,7 @@ void map::grow_plant( const tripoint_bub_ms &p )
             target_stage = pair.first;
         } // Don't break the loop for the case where time has been rewound.
         // Advance to the time of the next stage for the next iteration.
-        time_to_grow_to_this_stage += pair.second;
+        time_to_grow_to_this_stage += pair.second * ::get_option<float>( "CROP_GROWTH_TIME_SCALER" );
     }
 
     const auto check_flag = []( const std::string & to_check ) {
diff --git a/src/npc.cpp b/src/npc.cpp
index ee8fb7979d8c..647c38293e46 100644
--- a/src/npc.cpp
+++ b/src/npc.cpp
@@ -2069,11 +2069,12 @@ ret_val<void> npc::wants_to_buy( const item &it, int at_price ) const
     }
 
 
-    if( it.has_flag( flag_TRADER_AVOID ) || it.has_var( VAR_TRADE_IGNORE ) ) {
+    if( ::get_option<bool>( "TRADER_AVOID_ITEMS" ) &&
+            ( it.has_flag( flag_TRADER_AVOID ) || it.has_var( VAR_TRADE_IGNORE ) ) ) {
         return ret_val<void>::make_failure( _( "Will never buy this" ) );
     }
 
-    if( it.is_filthy() ) {
+    if( ::get_option<bool>( "TRADER_AVOID_FILTHY" ) && it.is_filthy() ) {
         return ret_val<void>::make_failure( _( "Will not buy filthy items" ) );
     }
 
@@ -4037,5 +4038,3 @@ std::unique_ptr<talker> get_talker_for( npc *guy )
 {
     return std::make_unique<talker_npc>( guy );
 }
-
-
diff --git a/src/suffer.cpp b/src/suffer.cpp
index f0c234fac297..b35c7f978ebd 100644
--- a/src/suffer.cpp
+++ b/src/suffer.cpp
@@ -1112,9 +1112,9 @@ void suffer::from_other_mutations( Character &you )
     }
 
     bool should_mutate = you.has_trait( trait_UNSTABLE ) && !you.has_trait( trait_CHAOTIC_BAD ) &&
-                         one_turn_in( 48_hours );
+                         one_turn_in( 1_hours * ::get_option<int>( "UNSTABLE_TRAIT_MUTATION_TIME" ) );
     should_mutate |= ( you.has_trait( trait_CHAOTIC ) || you.has_trait( trait_CHAOTIC_BAD ) ) &&
-                     one_turn_in( 12_hours );
+                     one_turn_in( 1_hours * ::get_option<int>( "CHAOTIC_TRAIT_MUTATION_TIME" ) );
     if( should_mutate ) {
         you.mutate();
     }
