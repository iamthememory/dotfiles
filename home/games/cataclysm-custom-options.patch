diff --git a/data/core/external_options.json b/data/core/external_options.json
index 52b4263204f4..c9512f4245b1 100644
--- a/data/core/external_options.json
+++ b/data/core/external_options.json
@@ -520,5 +520,75 @@
     "//": "The maximum number of overmaps that an intersection can deviate from its gridded position. Cannot be greater than or equal to row / 2 or column / 2, may cause bugs for > row / 4, column / 4.",
     "stype": "int",
     "value": 2
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "UNSTABLE_TRAIT_MUTATION_TIME",
+    "//": "The average hours between mutations with the unstable trait.",
+    "stype": "int",
+    "value": 48
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "CHAOTIC_TRAIT_MUTATION_TIME",
+    "//": "The average hours between mutations with the chaotic trait.",
+    "stype": "int",
+    "value": 12
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "BASE_MANA_REGEN_TIME",
+    "//": "How many hours it should take to regenerate all mana at base mana regen.",
+    "stype": "float",
+    "value": 8.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "BASE_MANA_REGEN_TIME",
+    "//": "How many hours it should take to regenerate all mana at base mana regen.",
+    "stype": "float",
+    "value": 8.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "CROP_GROWTH_TIME_SCALER",
+    "//": "A scaler for how long crops take to grow. 0.5 will make crops take half as much time to grow.",
+    "stype": "float",
+    "value": 1.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "SHELF_LIFE_MULTIPLIER",
+    "//": "How much longer than normal foods will last. 2.0 will cause foods to last twice as long.",
+    "stype": "float",
+    "value": 1.0
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "TRADER_AVOID_ITEMS",
+    "//": "Whether traders will respect the TRADER_AVOID flag and refuse to buy items marked with it.",
+    "stype": "bool",
+    "value": true
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "TRADER_AVOID_FILTHY",
+    "//": "Whether traders will refuse to buy filthy items or not.",
+    "stype": "bool",
+    "value": true
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "DONT_AUTOLEARN_BOOK_RECIPES",
+    "//": "Whether to prevent autolearning recipes which can be learned via a book.",
+    "stype": "bool",
+    "value": false
+  },
+  {
+    "type": "EXTERNAL_OPTION",
+    "name": "DONT_AUTOLEARN_DISASSEMBLY_RECIPES",
+    "//": "Whether to prevent autolearning recipes which can be learned via disassembly.",
+    "stype": "bool",
+    "value": false
   }
 ]
diff --git a/src/activity_item_handling.cpp b/src/activity_item_handling.cpp
index 6f72daac2f7b..1dbad53cfe8c 100644
--- a/src/activity_item_handling.cpp
+++ b/src/activity_item_handling.cpp
@@ -4389,8 +4389,9 @@ static int get_comestible_order( Character &you, const item_location &loc,
 static time_duration get_comestible_time_left( const item_location &loc )
 {
     time_duration time_left = 0_turns;
-    const time_duration shelf_life = loc->is_comestible() ? loc->get_comestible()->spoils :
-                                     calendar::INDEFINITELY_LONG_DURATION;
+    const time_duration shelf_life =
+        loc->is_comestible() ? loc->get_comestible()->spoils  * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" ):
+                calendar::INDEFINITELY_LONG_DURATION;
     if( shelf_life > 0_turns ) {
         const item &it = *loc;
         const double relative_rot = it.get_relative_rot();
diff --git a/src/game_inventory.cpp b/src/game_inventory.cpp
index b9e1db47997d..f1e12a3e71c4 100644
--- a/src/game_inventory.cpp
+++ b/src/game_inventory.cpp
@@ -717,8 +717,9 @@ class comestible_inventory_preset : public inventory_selector_preset
             }, _( "HEALTH" ) );
 
             append_cell( []( const item_location & loc ) {
-                const time_duration spoils = loc->is_comestible() ? loc->get_comestible()->spoils :
-                                             calendar::INDEFINITELY_LONG_DURATION;
+                const time_duration spoils =
+                        loc->is_comestible() ? loc->get_comestible()->spoils * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" ) :
+                                calendar::INDEFINITELY_LONG_DURATION;
                 if( spoils > 0_turns ) {
                     return to_string_clipped( spoils );
                 }
diff --git a/src/item_degrade.cpp b/src/item_degrade.cpp
index d268dd459534..8473c641c486 100644
--- a/src/item_degrade.cpp
+++ b/src/item_degrade.cpp
@@ -437,9 +437,9 @@ time_duration item::get_shelf_life() const
 {
     if( goes_bad() ) {
         if( is_comestible() ) {
-            return get_comestible()->spoils;
+            return get_comestible()->spoils * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" );
         } else if( is_corpse() ) {
-            return 24_hours;
+            return 24_hours * ::get_option<float>( "SHELF_LIFE_MULTIPLIER" );
         }
     }
     return 0_turns;
diff --git a/src/magic.cpp b/src/magic.cpp
index 27f9f39a42cf..2ece788f73c9 100644
--- a/src/magic.cpp
+++ b/src/magic.cpp
@@ -2477,7 +2477,8 @@ int known_magic::max_mana( const Character &guy ) const
 void known_magic::update_mana( const Character &guy, float turns )
 {
     // mana should replenish in 8 hours.
-    const double full_replenish = to_turns<double>( 8_hours );
+    const double full_replenish =
+        to_turns<double>( 1_hours ) * ::get_option<float>( "BASE_MANA_REGEN_TIME" );
     const double ratio = turns / full_replenish;
     mod_mana( guy, std::floor( ratio * std::max( 0.0,
                                guy.calculate_by_enchantment( static_cast<double>( max_mana(
diff --git a/src/map.cpp b/src/map.cpp
index ea21f3801f08..dc741581f778 100644
--- a/src/map.cpp
+++ b/src/map.cpp
@@ -8717,7 +8717,7 @@ void map::grow_plant( const tripoint_bub_ms &p )
             target_stage = pair.first;
         } // Don't break the loop for the case where time has been rewound.
         // Advance to the time of the next stage for the next iteration.
-        time_to_grow_to_this_stage += pair.second;
+        time_to_grow_to_this_stage += pair.second * ::get_option<float>( "CROP_GROWTH_TIME_SCALER" );
     }
 
     const auto check_flag = []( const std::string & to_check ) {
diff --git a/src/npc.cpp b/src/npc.cpp
index 382fcb6a1f70..0d31b92335f1 100644
--- a/src/npc.cpp
+++ b/src/npc.cpp
@@ -2061,11 +2061,12 @@ ret_val<void> npc::wants_to_buy( const item &it, int at_price ) const
     }
 
 
-    if( it.has_flag( flag_TRADER_AVOID ) || it.has_var( VAR_TRADE_IGNORE ) ) {
+    if( ::get_option<bool>( "TRADER_AVOID_ITEMS" ) &&
+            ( it.has_flag( flag_TRADER_AVOID ) || it.has_var( VAR_TRADE_IGNORE ) ) ) {
         return ret_val<void>::make_failure( _( "Will never buy this" ) );
     }
 
-    if( it.is_filthy() ) {
+    if( ::get_option<bool>( "TRADER_AVOID_FILTHY" ) && it.is_filthy() ) {
         return ret_val<void>::make_failure( _( "Will not buy filthy items" ) );
     }
 
@@ -3998,5 +3999,3 @@ std::unique_ptr<talker> get_talker_for( npc *guy )
 {
     return std::make_unique<talker_npc>( guy );
 }
-
-
diff --git a/src/recipe.cpp b/src/recipe.cpp
index 8dfada73352d..fea187f38985 100644
--- a/src/recipe.cpp
+++ b/src/recipe.cpp
@@ -689,6 +689,13 @@ void recipe::finalize()
         }
     }
 
+    if( ( ::get_option<bool>( "DONT_AUTOLEARN_BOOK_RECIPES" ) && !booksets.empty() ) ||
+            ( ::get_option<bool>( "DONT_AUTOLEARN_DISASSEMBLY_RECIPES" ) && !learn_by_disassembly.empty() ) ) {
+        // Prevent autolearning, since there's a way to learn it in the world.
+        autolearn = false;
+        autolearn_requirements.clear();
+    }
+
     // ensure result name is always in front of the name for searching in crafting menu
     if( !name_.empty() && !is_practice() && !is_nested() && result_ ) {
         name_ = translation::to_translation( string_format( name_, result_->nname( makes_amount() ) ) );
diff --git a/src/suffer.cpp b/src/suffer.cpp
index f0c234fac297..b35c7f978ebd 100644
--- a/src/suffer.cpp
+++ b/src/suffer.cpp
@@ -1112,9 +1112,9 @@ void suffer::from_other_mutations( Character &you )
     }
 
     bool should_mutate = you.has_trait( trait_UNSTABLE ) && !you.has_trait( trait_CHAOTIC_BAD ) &&
-                         one_turn_in( 48_hours );
+                         one_turn_in( 1_hours * ::get_option<int>( "UNSTABLE_TRAIT_MUTATION_TIME" ) );
     should_mutate |= ( you.has_trait( trait_CHAOTIC ) || you.has_trait( trait_CHAOTIC_BAD ) ) &&
-                     one_turn_in( 12_hours );
+                     one_turn_in( 1_hours * ::get_option<int>( "CHAOTIC_TRAIT_MUTATION_TIME" ) );
     if( should_mutate ) {
         you.mutate();
     }
